import type { paths, components } from './schema-mar24-2025.js' // auto-generated by openapi-typescript
import createClient from 'openapi-fetch'
import type { AppLogger, AppConfig } from '../../config.js'

export type { paths, components }

/** aka 'Function' name.
 * Maybe I should just stick with FunctionName --- not sure that EndpointName is any better */
type EndpointName = string

type Client = ReturnType<typeof createClient<paths>>

export type FunctionEndpointInfo = components['schemas']['Function']

// TODO: Improve error handling. Use structured errors
export class APIClient {
  #client: Client
  #endpoints: Set<EndpointName> = new Set()
  #detailedEndpointInfo: Map<EndpointName, FunctionEndpointInfo> = new Map()

  #logger: AppLogger

  static async make(config: AppConfig) {
    const wrapperClient = new APIClient(config)
    wrapperClient.setDetailedEndpointInfo(
      new Map(await wrapperClient.getDetailedFunctionEndpointPairs())
    )
    return wrapperClient
  }

  private constructor(config: AppConfig) {
    this.#client = createClient<paths>({
      baseUrl: config.getDecisionServiceUrl(),
    })

    this.#logger = config.getLogger()
  }

  async updateWithProgram<T extends Client['POST'] | Client['PUT']>(
    endpointName: EndpointName,
    path: Parameters<T>[0],
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    init: any
  ) {
    if (!this.#endpoints.has(endpointName)) {
      const { data, error } = await this.#client.POST(path, init)
      if (data) {
        this.#endpoints.add(endpointName)
        this.#logger.info("Successfully POST'd program: ", data)
      } else if (error) {
        this.#logger.error('ERROR', error)
      }
    } else {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const { data, error } = await this.#client.PUT(path as any, init)
      if (data) {
        this.#endpoints.add(endpointName)
        this.#logger.info("Successfully PUT'd program: ", data)
      } else if (error) {
        this.#logger.error('ERROR when trying to PUT program', error)
      }
    }
  }

  async getSimpleFunctionEndpoints() {
    const { data, error } = await this.#client.GET('/functions', {})
    if (data) {
      return data
    } else {
      return error
    }
  }

  private async getDetailedFunctionEndpointPairs(): Promise<
    Array<[EndpointName, FunctionEndpointInfo]>
  > {
    await this.updateSimpleFunctionEndpointInfo()

    const endpointInfoPairs = await Promise.all(
      Array.from(this.#endpoints).map(async (fnName) => {
        const { data, error } = await this.#client.GET('/functions/{name}', {
          params: { path: { name: fnName } },
        })

        if (!data) {
          this.#logger.error('ERROR getDetailedFunctionEndpoints:', error)
          return null
        }

        return [fnName, data as FunctionEndpointInfo]
      })
    )

    return endpointInfoPairs.filter(
      (entry): entry is [EndpointName, FunctionEndpointInfo] => !!entry
    )
  }

  async updateDetailedFunctionEndpointInfo() {
    const endpoints = await this.getDetailedFunctionEndpointPairs()
    if (endpoints) {
      this.setDetailedEndpointInfo(new Map(endpoints))
    }
  }

  async getDetailedEndpointInfoMap() {
    await this.updateDetailedFunctionEndpointInfo()
    return this.#detailedEndpointInfo
  }

  async getInfoFor(functionName: EndpointName) {
    await this.updateDetailedFunctionEndpointInfo()
    return this.#detailedEndpointInfo.get(functionName)
  }

  setDetailedEndpointInfo(
    detailedEndpointInfo: Map<EndpointName, FunctionEndpointInfo>
  ) {
    this.#detailedEndpointInfo = detailedEndpointInfo
  }

  async updateSimpleFunctionEndpointInfo() {
    const { data, error } = await this.#client.GET('/functions', {})
    if (data) {
      const endpoints: EndpointName[] = data
        .map((fn) => fn.function?.name)
        .filter((n): n is string => n !== undefined)
      this.#endpoints = new Set(endpoints)
    } else {
      this.#logger.error(error)
    }
  }

  /**
   * Evaluates a function endpoint by making a POST request to the `/functions/{name}/evaluation` endpoint.
   *
   * @param functionName - The name of the function to evaluate.
   * @param args - The function arguments as per the `FnArguments` schema.
   * @returns A promise resolving to the data or error from the API response.
   */
  async evalFunctionEndpoint(
    functionName: EndpointName,
    args: components['schemas']['FnArguments']['fnArguments']
  ) {
    const { data, error } = await this.#client.POST(
      '/functions/{name}/evaluation',
      {
        params: { path: { name: functionName } },
        body: { fnArguments: args, fnEvalBackend: 'jl4' },
      }
    )

    // Log any errors
    if (error) {
      this.#logger.error('Error evaluateFunctionEndpoint', error)
      return
    }

    return { ok: data, error }
  }

  PUT: Client['PUT'] = (path, ...init) => {
    return this.#client.PUT(path, ...init)
  }

  DELETE: Client['DELETE'] = (path, ...init) => {
    return this.#client.DELETE(path, ...init)
  }
}
